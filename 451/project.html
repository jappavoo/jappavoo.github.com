<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<link rel="StyleSheet" href="https://pdos.csail.mit.edu/style.css" type="text/css">
<title>CS651 Project</title>
</head>

<body>
<div align="center">
<h2><a href="../cs451.html">CS451/651</a> - Spring 2017</h2>
</div>

<div align="center">
<h1>CS651 Project</h1>
</div>


<div align="center">

<table border=0>
<tr><td><b>Proposals due:</b></td>
    <td>March 3 23:59</td></tr>
<tr><td><b>Code and write-up due:</b></td>
    <td>Apr 21:59</td></tr>
<tr><td><b>Presentations:</b></td>
    <td>Apr 25, 27 and May 2</td></tr>
</table>

</div>

<hr>

<h2>Introduction</h2>

<p>
You will choose your own idea for a final project for this class.

<p>
You must get our approval for your idea in advance.
You must form a group of 2 or 3 CS651 students to collaborate on the project.
You'll turn in your code and a short write-up
describing the design and implementation of your project, and make
a short in-class presentation about your work.  We will post your write-up
and code on the web site after the end of the semester, unless you
explicitly talk to us about why you want to keep yours confidential.

<p>
Your project should be something interesting and challenging that's
closely related to CS651 core topics, such as fault tolerance. Below
you'll find some half-baked ideas that we think could turn into
interesting projects, but we haven't given them too much thought.

<p>
<h2>Deliverables</h2>

<p>
There are four concrete steps to the final project, as follows:

<ol>

<li>
Form a group and decide on the project you would like to work on.
Feel free to use Piazza to find group members and discuss ideas.
Course staff will be happy to discuss project ideas via e-mail or in
person.

<li>
Flesh out the exact problem you
will be addressing and how you will go about solving it.
By the proposal deadline, you must
submit a proposal (less than a page) describing: your <b>group members</b>
list, <b>the problem</b> you want to address, <b>how you plan to address it</b>,
and what are you proposing to <b>specifically design and implement</b>.
Submit your proposal using gsubmit and email a copy to the TF.
We'll tell you whether we approve, or not, and give you feedback.

<li>
Execute your project: design and build something neat!

<li>
Write a document describing the design and implementation of your project,
and turn it in along with your project's code by the final deadline.  The
document should be about 3 pages of text that helps us understand what
problem you solved, and what your code does.  The code and writeups will
be posted online after the end of the semester.

<li>
Prepare a short, 10-15 minute, in-class presentation about the work that you have
done for your final project.  We will provide a projector that you can use to
demonstrate your project. 

</ol>

<p>
<h2>Half-baked project ideas</h2>

<p>
Here's a list of ideas to get you started thinking -- but you should
feel free to propose your own ideas.

<ul>


<li> Build a distributed, decentralized, fault-tolerant reddit.

<li> Make the state synchronization protocol (DDP) in <a
href="http://www.meteor.com/">Meteor</a> more efficient (e.g., send
fewer bytes between server and client) and more fault-tolerant (e.g.,
a client should be able to tolerate server failures, as long as enough
servers remain live).

<li> Build a fault-tolerant file service; on the client side, you could
use FUSE to run your own client code, or you could have clients talk
NFS to your server, as in Harp.

<li> Build a better fault-tolerant peer-to-peer tracker for BitTorrent.

<li> Build a system for making Node.js applications fault-tolerant,
perhaps using some form of replicated execution.

<li> Add cross-shard atomic transactions to Lab 4, using two-phase commit
and/or snapshots.

<li> Build a system with asynchronous replication (like Dynamo or
Ficus or Bayou). Perhaps add stronger consistency (as in COPS
or Walter or Lynx).

<li> Build a file synchronizer (like
  <a href="http://www.cis.upenn.edu/~bcpierce/unison/">Unison</a> or
  <a href="http://swtch.com/tra/">Tra</a>).

<li> Build a
<a href="http://www.cdf.toronto.edu/~csc469h/fall/handouts/nitzberg91.pdf">distributed shared memory</a> (DSM) system, so that you can run
multi-threaded shared memory parallel programs on a cluster of
machines, using paging to give the appearance of real shared memory.
When a thread tries to access a page that's on another machine, the
page fault will give the DSM system a chance to fetch the page over
the network from whatever machine currently stores.

<li> Build a distributed RAID in the style of FAB.
Maybe you can get standard operating systems
to talk to you network virtual disk using iSCSI or
Linux's NBD (network block device).

<li> Build a coherent caching system for use by web sites (a bit
like memcached), perhaps along the lines of
<a href="http://drkp.net/papers/txcache-osdi10.pdf">TxCache</a>.

<li> Build a distributed cooperative web cache, perhaps along
the lines of
<a href="https://www.usenix.org/legacy/events/iptps09/tech/full_papers/terrace/terrace_html/">Firecoral</a> or
<a href="http://www.ccs.neu.edu/home/amislove/publications/Maygh-EuroSys.pdf">Maygh</a>.

<li> Build a collaborative editor like EtherPad.

</ul>
</body></html>
